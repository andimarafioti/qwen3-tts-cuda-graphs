<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Faster Qwen3-TTS</title>
  <style>
    *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

    :root {
      --bg:           #080808;
      --surface:      #101010;
      --surface2:     #161616;
      --border:       #1d1d1d;
      --border2:      #2a2a2a;
      --text:         #e2e2e2;
      --dim:          #5a5a5a;
      --dimmer:       #303030;
      --accent:       #06b6d4;
      --accent-bg:    rgba(6, 182, 212, 0.08);
      --accent-ring:  rgba(6, 182, 212, 0.22);
      --green:        #10b981;
      --amber:        #f59e0b;
      --red:          #ef4444;
    }

    body {
      background: var(--bg);
      color: var(--text);
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
      font-size: 14px;
      line-height: 1.55;
      min-height: 100vh;
      padding: 32px 16px 80px;
    }

    .wrap { max-width: 660px; margin: 0 auto; }

    /* â”€â”€ Header â”€â”€ */
    .hdr { margin-bottom: 28px; }
    .hdr-top { display: flex; align-items: baseline; gap: 10px; margin-bottom: 4px; }
    .hdr h1 {
      font-size: 20px; font-weight: 600; letter-spacing: -0.4px; color: #f0f0f0;
    }
    .badge {
      font-size: 10px; font-weight: 600; letter-spacing: 0.8px;
      background: var(--accent-bg); color: var(--accent);
      border: 1px solid var(--accent-ring);
      padding: 2px 7px; border-radius: 100px;
    }
    .hdr p { font-size: 13px; color: var(--dim); }

    /* â”€â”€ Model bar â”€â”€ */
    .model-bar {
      display: flex; align-items: center; gap: 10px;
      padding: 9px 12px;
      background: var(--surface); border: 1px solid var(--border); border-radius: 8px;
      margin-bottom: 14px;
    }
    .model-bar label { font-size: 11px; color: var(--dim); white-space: nowrap; }
    #modelSelect {
      flex: 1; background: transparent; border: none; color: var(--text);
      font-size: 13px; font-family: inherit; outline: none; cursor: pointer;
    }
    #modelSelect option { background: #1a1a1a; }
    .model-pill {
      display: flex; align-items: center; gap: 5px;
      font-size: 11px; color: var(--dim); white-space: nowrap;
    }
    .mdot {
      width: 6px; height: 6px; border-radius: 50%;
      background: var(--dimmer); flex-shrink: 0;
      transition: background 0.3s;
    }
    .mdot.loaded  { background: var(--green); }
    .mdot.loading { background: var(--amber); animation: blink 0.7s infinite; }
    .mdot.error   { background: var(--red); }

    /* â”€â”€ Card â”€â”€ */
    .card {
      background: var(--surface); border: 1px solid var(--border);
      border-radius: 12px; padding: 20px; margin-bottom: 10px;
    }

    /* â”€â”€ Tabs â”€â”€ */
    .tabs {
      display: flex; gap: 0; margin-bottom: 20px;
      border-bottom: 1px solid var(--border);
    }
    .tab {
      padding: 7px 14px; font-size: 13px; font-weight: 500;
      color: var(--dim); cursor: pointer;
      border-bottom: 2px solid transparent; margin-bottom: -1px;
      transition: color 0.15s, border-color 0.15s;
      user-select: none;
    }
    .tab:hover { color: var(--text); }
    .tab.active { color: var(--accent); border-bottom-color: var(--accent); }
    .tab-pane { display: none; }
    .tab-pane.active { display: block; }

    /* â”€â”€ Fields â”€â”€ */
    .field { margin-bottom: 14px; }
    .field > label {
      display: block; font-size: 11px; font-weight: 500;
      color: var(--dim); margin-bottom: 5px;
      text-transform: uppercase; letter-spacing: 0.6px;
    }
    textarea, input[type="text"] {
      width: 100%; background: var(--surface2);
      border: 1px solid var(--border); border-radius: 7px;
      color: var(--text); font-size: 14px; font-family: inherit;
      padding: 9px 11px; resize: vertical; outline: none;
      transition: border-color 0.15s;
    }
    textarea:focus, input[type="text"]:focus { border-color: var(--border2); }
    textarea::placeholder, input::placeholder { color: var(--dimmer); }

    /* â”€â”€ Dropzone â”€â”€ */
    .dropzone {
      position: relative; border: 1.5px dashed var(--border2);
      border-radius: 8px; padding: 22px 16px; text-align: center;
      background: var(--surface2); cursor: pointer;
      transition: border-color 0.15s, background 0.15s;
    }
    .dropzone:hover, .dropzone.over {
      border-color: var(--accent); background: var(--accent-bg);
    }
    .dropzone input[type="file"] {
      position: absolute; inset: 0; opacity: 0; cursor: pointer;
    }
    .dz-icon { font-size: 22px; margin-bottom: 5px; }
    .dz-hint { font-size: 12px; color: var(--dim); }
    .dz-name { font-size: 12px; color: var(--accent); margin-top: 4px; font-weight: 500; }

    /* â”€â”€ Row â”€â”€ */
    .row2 { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; }
    .row3 { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 12px; }

    /* â”€â”€ Select â”€â”€ */
    select {
      width: 100%; background: var(--surface2);
      border: 1px solid var(--border); border-radius: 7px;
      color: var(--text); font-size: 13px; font-family: inherit;
      padding: 8px 28px 8px 10px; outline: none; cursor: pointer;
      appearance: none;
      background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='10' height='6' viewBox='0 0 10 6'%3E%3Cpath fill='%23555' d='M5 6 0 0h10z'/%3E%3C/svg%3E");
      background-repeat: no-repeat; background-position: right 10px center;
    }
    select option { background: #161616; }

    /* â”€â”€ Mode toggle â”€â”€ */
    .toggle {
      display: flex; background: var(--surface2);
      border: 1px solid var(--border); border-radius: 7px; padding: 3px;
    }
    .toggle-btn {
      flex: 1; padding: 5px 8px; font-size: 12px; font-weight: 500;
      text-align: center; cursor: pointer; border-radius: 5px;
      color: var(--dim); transition: all 0.15s; user-select: none;
    }
    .toggle-btn.active {
      background: var(--surface); color: var(--text);
      box-shadow: 0 1px 3px rgba(0,0,0,0.5);
    }

    /* â”€â”€ Slider â”€â”€ */
    .slider-wrap { display: flex; align-items: center; gap: 10px; }
    input[type="range"] {
      -webkit-appearance: none; flex: 1;
      height: 3px; background: var(--border2); border-radius: 2px;
      outline: none; cursor: pointer;
    }
    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none; width: 13px; height: 13px;
      border-radius: 50%; background: var(--accent);
      cursor: pointer; transition: transform 0.1s;
    }
    input[type="range"]::-webkit-slider-thumb:hover { transform: scale(1.25); }
    .sval {
      font-size: 11px; font-family: 'SF Mono', 'Fira Code', monospace;
      color: var(--dim); min-width: 36px; text-align: right;
    }

    /* â”€â”€ Collapsible advanced â”€â”€ */
    .adv-toggle {
      display: flex; align-items: center; gap: 5px;
      font-size: 12px; color: var(--dim); cursor: pointer;
      user-select: none; margin-top: 6px; width: fit-content;
    }
    .adv-toggle:hover { color: var(--text); }
    .adv-body {
      display: none; margin-top: 14px; padding-top: 14px;
      border-top: 1px solid var(--border);
    }
    .adv-body.open { display: block; }

    /* â”€â”€ Generate button â”€â”€ */
    .btn-gen {
      width: 100%; padding: 12px; font-size: 14px; font-weight: 600;
      font-family: inherit; letter-spacing: -0.2px;
      background: var(--accent); color: #000; border: none; border-radius: 8px;
      cursor: pointer; transition: background 0.15s, transform 0.1s;
    }
    .btn-gen:hover:not(:disabled) { background: #22d3ee; transform: translateY(-1px); }
    .btn-gen:active:not(:disabled) { transform: translateY(0); }
    .btn-gen:disabled {
      opacity: 0.45; cursor: not-allowed; transform: none;
      background: var(--surface2); color: var(--dim);
      border: 1px solid var(--border2);
    }

    /* â”€â”€ Small buttons â”€â”€ */
    .btn-sm {
      font-size: 12px; padding: 5px 12px;
      background: transparent; border: 1px solid var(--border2);
      border-radius: 6px; color: var(--dim); cursor: pointer;
      font-family: inherit; transition: all 0.15s; white-space: nowrap;
    }
    .btn-sm:hover { border-color: var(--accent); color: var(--accent); }

    /* â”€â”€ Error â”€â”€ */
    .err {
      display: none; margin-top: 10px; padding: 10px 12px;
      background: rgba(239,68,68,0.07); border: 1px solid rgba(239,68,68,0.18);
      border-radius: 8px; color: #fca5a5; font-size: 13px;
    }
    .err.show { display: block; }

    /* â”€â”€ Metrics card â”€â”€ */
    .m-card { display: none; }
    .m-card.show { display: block; }

    .m-header {
      display: flex; align-items: center; gap: 8px;
      margin-bottom: 16px;
      font-size: 11px; font-weight: 600; letter-spacing: 0.8px;
      text-transform: uppercase; color: var(--dim);
    }
    .sdot {
      width: 7px; height: 7px; border-radius: 50%;
      background: var(--accent); flex-shrink: 0;
    }
    .sdot.done   { background: var(--green); }
    .sdot.error  { background: var(--red); }
    .sdot.active { animation: blink 0.75s infinite; }

    @keyframes blink { 0%,100%{opacity:1} 50%{opacity:0.2} }

    /* â”€â”€ Metric grid â”€â”€ */
    .mgrid {
      display: grid; grid-template-columns: repeat(3, 1fr);
      gap: 1px; background: var(--border); border-radius: 8px;
      overflow: hidden; margin-bottom: 14px;
    }
    .mbox { background: var(--surface2); padding: 14px 16px; }
    .mlabel {
      font-size: 10px; text-transform: uppercase; letter-spacing: 0.9px;
      color: var(--dim); margin-bottom: 6px;
    }
    .mval {
      font-family: 'SF Mono', 'JetBrains Mono', 'Fira Code', monospace;
      font-size: 26px; font-weight: 600; color: #f0f0f0;
      letter-spacing: -1.5px; line-height: 1;
    }
    .munit { font-size: 12px; color: var(--dim); font-weight: 400; letter-spacing: 0; margin-left: 1px; }
    .mhint { font-size: 10px; color: var(--dimmer); margin-top: 4px; }

    /* â”€â”€ Progress bar â”€â”€ */
    .ptrack {
      height: 2px; background: var(--border2); border-radius: 2px;
      overflow: hidden; margin-bottom: 14px;
    }
    .pfill {
      height: 100%; background: var(--accent); border-radius: 2px;
      transition: width 0.4s ease; width: 0%;
    }
    .pfill.spin {
      width: 25% !important;
      animation: sweep 1.4s ease-in-out infinite;
    }
    @keyframes sweep {
      0%   { transform: translateX(-200%); }
      100% { transform: translateX(500%); }
    }

    /* â”€â”€ Wave indicator â”€â”€ */
    .wave-row {
      display: flex; align-items: center; gap: 8px;
      font-size: 12px; color: var(--dim); margin-bottom: 12px;
    }
    .wave-row.hidden { display: none; }
    .bars { display: flex; align-items: center; gap: 2px; height: 14px; }
    .bar {
      width: 2px; border-radius: 1px; background: var(--accent);
      animation: wavebar 0.7s ease-in-out infinite;
    }
    .bar:nth-child(1) { height: 4px;  animation-delay: 0s;    }
    .bar:nth-child(2) { height: 8px;  animation-delay: 0.10s; }
    .bar:nth-child(3) { height: 13px; animation-delay: 0.20s; }
    .bar:nth-child(4) { height: 8px;  animation-delay: 0.30s; }
    .bar:nth-child(5) { height: 4px;  animation-delay: 0.40s; }
    @keyframes wavebar { 0%,100%{transform:scaleY(0.35)} 50%{transform:scaleY(1)} }

    /* â”€â”€ Audio section â”€â”€ */
    .audio-wrap { display: none; }
    .audio-wrap.show { display: block; }
    audio {
      width: 100%; border-radius: 6px; margin-bottom: 8px;
      /* minimal consistent look across browsers */
      filter: invert(0);
    }
    .audio-row { display: flex; justify-content: flex-end; gap: 8px; }

    /* â”€â”€ Chunk size row (streaming only) â”€â”€ */
    #chunkRow { display: none; }
    #chunkRow.show { display: block; }

    /* â”€â”€ RTF hint â”€â”€ */
    .rtf-hint {
      font-size: 11px; color: var(--dimmer); text-align: center;
      margin-top: -8px; margin-bottom: 4px;
    }

    /* â”€â”€ Switch model prompt â”€â”€ */
    .switch-prompt {
      display: none; margin-top: 10px; padding: 12px 14px;
      background: rgba(245,158,11,0.07); border: 1px solid rgba(245,158,11,0.2);
      border-radius: 8px; font-size: 13px; color: #fcd34d;
      align-items: center; gap: 10px; flex-wrap: wrap;
    }
    .switch-prompt.show { display: flex; }
    .switch-prompt code {
      background: rgba(245,158,11,0.12); padding: 1px 6px; border-radius: 4px;
      font-size: 12px; color: #fde68a;
    }
    .switch-prompt .sp-btns { display: flex; gap: 6px; margin-left: auto; }
    .btn-switch {
      font-size: 12px; padding: 5px 12px; border-radius: 6px; cursor: pointer;
      font-family: inherit; border: none; font-weight: 500;
      background: rgba(245,158,11,0.2); color: #fcd34d;
      transition: background 0.15s;
    }
    .btn-switch:hover { background: rgba(245,158,11,0.35); }
    .btn-cancel-sw {
      font-size: 12px; padding: 5px 10px; border-radius: 6px; cursor: pointer;
      font-family: inherit; border: 1px solid var(--border2);
      background: transparent; color: var(--dim); transition: all 0.15s;
    }
    .btn-cancel-sw:hover { color: var(--text); border-color: var(--border2); }
  </style>
</head>
<body>
<div class="wrap">

  <!-- Header -->
  <header class="hdr">
    <div class="hdr-top">
      <h1>faster-qwen3-tts</h1>
      <span class="badge">CUDA GRAPHS</span>
    </div>
    <p>Real-time TTS â€” watch TTFA and RTF update live as audio streams to your speakers</p>
  </header>

  <!-- Model bar -->
  <div class="model-bar">
    <label>Model</label>
    <select id="modelSelect">
      <option value="Qwen/Qwen3-TTS-12Hz-0.6B-Base">0.6B Base</option>
      <option value="Qwen/Qwen3-TTS-12Hz-1.7B-Base">1.7B Base</option>
      <option value="Qwen/Qwen3-TTS-12Hz-1.7B-VoiceDesign">1.7B VoiceDesign</option>
    </select>
    <div class="model-pill">
      <div class="mdot" id="mdot"></div>
      <span id="mtext">not loaded</span>
    </div>
    <button class="btn-sm" id="loadBtn" onclick="loadModel()">Load</button>
  </div>

  <!-- Main form card -->
  <div class="card">

    <!-- Tabs -->
    <div class="tabs">
      <div class="tab active" id="tabClone" onclick="switchTab('clone')">Voice Clone</div>
      <div class="tab" id="tabDesign" onclick="switchTab('design')">Voice Design</div>
    </div>

    <!-- Voice Clone pane -->
    <div class="tab-pane active" id="paneClone">
      <div class="field">
        <label>Text</label>
        <textarea id="cloneText" rows="4"
          placeholder="Enter text to synthesizeâ€¦">Hello! This is faster Qwen3-TTS running with CUDA graph capture. Notice how the audio starts playing almost immediately â€” that's the time-to-first-audio advantage of streaming inference.</textarea>
      </div>
      <div class="field">
        <label>Reference Audio <span style="font-weight:400;text-transform:none;letter-spacing:0;color:var(--dimmer)">â€” drop a short WAV clip of the target voice</span></label>
        <div class="dropzone" id="dz"
          ondragover="dzOver(event)" ondragleave="dzLeave(event)" ondrop="dzDrop(event)">
          <input type="file" id="refAudio" accept=".wav,.mp3,.flac,.ogg" onchange="dzPick(event)">
          <div class="dz-icon">ðŸŽ™</div>
          <div class="dz-hint">Drop a WAV here or click to browse</div>
          <div class="dz-name" id="dzName"></div>
        </div>
      </div>
      <div class="field">
        <label>Reference Transcript</label>
        <textarea id="refText" rows="2"
          placeholder="Transcription of the reference audio clipâ€¦"></textarea>
      </div>
    </div>

    <!-- Voice Design pane -->
    <div class="tab-pane" id="paneDesign">
      <div class="field">
        <label>Text</label>
        <textarea id="designText" rows="4"
          placeholder="Enter text to synthesizeâ€¦">Welcome! This demonstration shows voice design â€” describe any voice and the model will synthesize speech in that style, streamed in real time with CUDA graphs.</textarea>
      </div>
      <div class="field">
        <label>Voice Instruction</label>
        <textarea id="instruct" rows="2"
          placeholder="e.g. A warm, confident female voice with a slight British accentâ€¦">A warm, calm narrator with a clear and engaging delivery.</textarea>
      </div>
      <p style="font-size:12px;color:var(--dimmer);margin-top:-8px;margin-bottom:6px">
        Requires the <code style="color:var(--dim)">1.7B-VoiceDesign</code> model.
      </p>
    </div>

    <!-- Common options row -->
    <div class="row2" style="margin-top:4px">
      <div class="field">
        <label>Language</label>
        <select id="language">
          <option>English</option>
          <option>Chinese</option>
          <option>French</option>
          <option>German</option>
          <option>Spanish</option>
          <option>Auto</option>
        </select>
      </div>
      <div class="field">
        <label>Generation Mode</label>
        <div class="toggle">
          <div class="toggle-btn active" id="modeStream" onclick="setMode('stream')">Streaming</div>
          <div class="toggle-btn" id="modeNon" onclick="setMode('non')">Non-streaming</div>
        </div>
      </div>
    </div>

    <!-- Chunk size (streaming only) -->
    <div id="chunkRow" class="field show">
      <label>
        Chunk Size
        <span style="font-weight:400;text-transform:none;letter-spacing:0;color:var(--dimmer)">â€” smaller = lower TTFA, higher overhead</span>
      </label>
      <div class="slider-wrap">
        <input type="range" id="chunkSize" min="1" max="24" value="8"
          oninput="sv(this,'chunkVal')">
        <span class="sval" id="chunkVal">8</span>
      </div>
    </div>

    <!-- Advanced -->
    <div class="adv-toggle" onclick="toggleAdv()">
      <span id="advArr">â–¸</span> Advanced
    </div>
    <div class="adv-body" id="advBody">
      <div class="row3">
        <div class="field">
          <label>Temperature</label>
          <div class="slider-wrap">
            <input type="range" id="temperature" min="0.1" max="2.0" step="0.05" value="0.9"
              oninput="sv(this,'tempVal')">
            <span class="sval" id="tempVal">0.9</span>
          </div>
        </div>
        <div class="field">
          <label>Top-K</label>
          <div class="slider-wrap">
            <input type="range" id="topK" min="1" max="100" value="50"
              oninput="sv(this,'topKVal')">
            <span class="sval" id="topKVal">50</span>
          </div>
        </div>
        <div class="field">
          <label>Rep. Penalty</label>
          <div class="slider-wrap">
            <input type="range" id="repPenalty" min="1.0" max="1.5" step="0.01" value="1.05"
              oninput="sv(this,'rpVal')">
            <span class="sval" id="rpVal">1.05</span>
          </div>
        </div>
      </div>
    </div>

  </div><!-- /card -->

  <button class="btn-gen" id="genBtn" onclick="generate()">Generate</button>
  <div class="switch-prompt" id="switchPrompt">
    <span id="switchMsg"></span>
    <div class="sp-btns">
      <button class="btn-switch" id="switchBtn">Load it &amp; generate</button>
      <button class="btn-cancel-sw" onclick="dismissSwitch()">Cancel</button>
    </div>
  </div>
  <div class="err" id="errMsg"></div>

  <!-- Metrics card -->
  <div class="card m-card" id="mCard">

    <div class="m-header">
      <div class="sdot active" id="sdot"></div>
      <span id="stext">Generatingâ€¦</span>
    </div>

    <div class="mgrid">
      <div class="mbox">
        <div class="mlabel">Audio Path</div>
        <div class="mval" id="mAudioPath">â€”</div>
        <div class="mhint">worklet vs fallback</div>
      </div>
      <div class="mbox">
        <div class="mlabel">TTFA</div>
        <div class="mval" id="mTTFA">â€”</div>
        <div class="mhint">time to first audio</div>
      </div>
      <div class="mbox">
        <div class="mlabel">Client TTFA</div>
    <div class="mval" id="mTTFAClient">â€”</div>
    <div class="mhint">first sound heard</div>
      </div>
      <div class="mbox">
        <div class="mlabel">Voice Clone</div>
        <div class="mval" id="mVC">â€”</div>
        <div class="mhint">prompt build</div>
      </div>
      <div class="mbox">
        <div class="mlabel">Server Wall</div>
        <div class="mval" id="mServerWall">â€”</div>
        <div class="mhint">to first chunk</div>
      </div>
      <div class="mbox">
        <div class="mlabel">WAV Encode</div>
        <div class="mval" id="mWavMs">â€”</div>
        <div class="mhint">server per chunk</div>
      </div>
      <div class="mbox">
        <div class="mlabel">Base64</div>
        <div class="mval" id="mB64Ms">â€”</div>
        <div class="mhint">server per chunk</div>
      </div>
      <div class="mbox">
        <div class="mlabel">RTF</div>
        <div class="mval" id="mRTF">â€”</div>
        <div class="mhint">&gt;1Ã— = faster than real-time</div>
      </div>
      <div class="mbox">
        <div class="mlabel">Generated</div>
        <div class="mval" id="mDur">â€”</div>
        <div class="mhint">total audio duration</div>
      </div>
      <div class="mbox">
        <div class="mlabel">Buffer</div>
    <div class="mval" id="mBuf">â€”</div>
    <div class="mhint">queued audio</div>
      </div>
      <div class="mbox">
        <div class="mlabel">Net+Client</div>
    <div class="mval" id="mNetClient">â€”</div>
    <div class="mhint">after server</div>
  </div>
      <div class="mbox">
        <div class="mlabel">Init</div>
        <div class="mval" id="mInit">â€”</div>
        <div class="mhint">audio init</div>
      </div>
      <div class="mbox">
        <div class="mlabel">Worklet Load</div>
        <div class="mval" id="mWorklet">â€”</div>
        <div class="mhint">module load</div>
      </div>
      <div class="mbox">
        <div class="mlabel">First Msg</div>
        <div class="mval" id="mFirstMsg">â€”</div>
        <div class="mhint">to worklet</div>
      </div>
    </div>

    <div class="ptrack"><div class="pfill spin" id="pbar"></div></div>

    <div class="wave-row" id="waveRow">
      <div class="bars">
        <div class="bar"></div><div class="bar"></div><div class="bar"></div>
        <div class="bar"></div><div class="bar"></div>
      </div>
      <span>Streaming audioâ€¦</span>
    </div>

    <!-- Audio replay / download (shown after done) -->
    <div class="audio-wrap" id="audioWrap">
      <audio id="player" controls></audio>
      <div class="audio-row">
        <button class="btn-sm" onclick="dlAudio()">â†“ Download WAV</button>
      </div>
    </div>

  </div><!-- /metrics card -->

</div><!-- /wrap -->

<script>
// â”€â”€â”€ State â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let activeTab       = 'clone';
let genMode         = 'stream';
let refFile         = null;
let refB64          = null;
let refId           = null;
let busy            = false;
let loadedModelName = null;
let useWebSocket    = true;

// Web Audio
let actx        = null;
let workletNode = null;
let workletReady = false;
let pcmQueue    = [];     // legacy fallback (unused)
let sproc       = null;
let sprocActive = false;
let pendingChunks = [];
let keepAlive = null;
let rawPcmParts = [];     // raw int16 bytes from server (for download WAV)
let rawPcmSr    = 24000;
let chunkQ      = Promise.resolve();
let clientT0    = 0;
let firstChunkAt = null;
let firstAudioAt = null;
let lastBufS     = 0;
let firstServerWall = null;
let initAudioAt = null;
let workletLoadedAt = null;
let firstWorkletMsgAt = null;

// Download
let dlBlob = null;

// â”€â”€â”€ Init â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
window.addEventListener('load', () => {
  fetchStatus();
  // Pre-warm audio graph to avoid first-run latency.
  setTimeout(() => { warmAudio(); }, 0);
  // Ensure warmup runs after a user gesture (autoplay policies).
  const _warmOnce = () => { warmAudio(); window.removeEventListener('pointerdown', _warmOnce); };
  window.addEventListener('pointerdown', _warmOnce, { passive: true });
});

async function fetchStatus() {
  try {
    const d = await fetch('/status').then(r => r.json());
    if (d.model) {
      loadedModelName = d.model;
      const sel = document.getElementById('modelSelect');
      for (const o of sel.options) { if (o.value === d.model) { o.selected = true; break; } }
    }
    setModelPill(d.loaded ? 'loaded' : 'off', d.model ? 'ready' : 'not loaded');
  } catch { setModelPill('off', 'offline'); }
}

// â”€â”€â”€ Model â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async function loadModel() {
  const modelId = document.getElementById('modelSelect').value;
  const btn = document.getElementById('loadBtn');
  btn.disabled = true; btn.textContent = 'Loadingâ€¦';
  setModelPill('loading', 'loadingâ€¦');

  try {
    const fd = new FormData();
    fd.append('model_id', modelId);
    const d = await fetch('/load', { method: 'POST', body: fd }).then(r => r.json());
    if (d.status === 'loaded' || d.status === 'already_loaded') {
      loadedModelName = modelId;
      setModelPill('loaded', 'ready');
    } else {
      setModelPill('error', 'failed');
    }
  } catch (e) {
    setModelPill('error', 'error');
  }
  btn.disabled = false; btn.textContent = 'Load';
}

function setModelPill(state, label) {
  const dot = document.getElementById('mdot');
  dot.className = 'mdot ' + state;
  document.getElementById('mtext').textContent = label;
}

// â”€â”€â”€ Tabs â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function switchTab(t) {
  activeTab = t;
  document.getElementById('tabClone').classList.toggle('active', t === 'clone');
  document.getElementById('tabDesign').classList.toggle('active', t === 'design');
  document.getElementById('paneClone').classList.toggle('active', t === 'clone');
  document.getElementById('paneDesign').classList.toggle('active', t === 'design');
}

// â”€â”€â”€ Mode toggle â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function setMode(m) {
  genMode = m;
  document.getElementById('modeStream').classList.toggle('active', m === 'stream');
  document.getElementById('modeNon').classList.toggle('active', m === 'non');
  document.getElementById('chunkRow').classList.toggle('show', m === 'stream');
}

// â”€â”€â”€ Slider helper â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function sv(el, id) { document.getElementById(id).textContent = el.value; }

// â”€â”€â”€ Advanced toggle â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function toggleAdv() {
  const open = document.getElementById('advBody').classList.toggle('open');
  document.getElementById('advArr').textContent = open ? 'â–¾' : 'â–¸';
}

// â”€â”€â”€ Dropzone â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function dzOver(e) { e.preventDefault(); document.getElementById('dz').classList.add('over'); }
function dzLeave()  { document.getElementById('dz').classList.remove('over'); }
function dzDrop(e) {
  e.preventDefault(); dzLeave();
  const f = e.dataTransfer.files[0]; if (f) setRef(f);
}
function dzPick(e) { const f = e.target.files[0]; if (f) setRef(f); }
function setRef(f) {
  refFile = f;
  refB64 = null;
  refId = null;
  document.getElementById('dzName').textContent = 'âœ“ ' + f.name;
  const reader = new FileReader();
  reader.onload = () => {
    const res = reader.result || '';
    const parts = res.split(',');
    refB64 = parts.length > 1 ? parts[1] : null;
    if (refB64) {
      // lightweight id for cache key
      refId = 'ref_' + refB64.length + '_' + (refB64.slice(0, 12));
    }
  };
  reader.readAsDataURL(f);
}

// â”€â”€â”€ Web Audio: gapless streaming via ScriptProcessor + raw PCM â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Skips decodeAudioData entirely â€” parsing int16 PCM directly from the server's
// WAV bytes avoids per-chunk resampling boundary artifacts. AudioContext runs at
// the model's native 12 kHz so the browser resamples one continuous stream
// to the device rate rather than each chunk independently.
async function warmAudio() {
  if (actx) return;
  try {
    await initAudio(24000);
  } catch (e) {
    console.warn('Audio warmup failed (will retry on generate):', e);
  }
}

async function initAudio(sr) {
  if (actx) {
    initAudioAt = performance.now();
    rawPcmSr = sr || rawPcmSr;
    pcmQueue = [];
    rawPcmParts = [];
    chunkQ = Promise.resolve();
    dlBlob = null;
    firstChunkAt = null;
    firstAudioAt = null;
    lastBufS = 0;
    pendingChunks = [];
    // If worklet never initialized (e.g., autoplay blocked), rebuild it.
    if (!workletNode) {
      try { await actx.close(); } catch {}
      actx = null;
    } else {
      if (actx.state === 'suspended') {
        try { await actx.resume(); } catch {}
      }
      workletReady = true;
      document.getElementById('mAudioPath').innerHTML = 'AudioWorklet';
      // Keep the audio graph alive with a silent oscillator.
      if (!keepAlive) {
        const gain = actx.createGain();
        gain.gain.value = 0;
        const osc = actx.createOscillator();
        osc.connect(gain).connect(actx.destination);
        osc.start();
        keepAlive = { osc, gain };
      }
      pushClientMetrics();
      return;
    }
  }
  initAudioAt = performance.now();
  rawPcmSr    = sr || 24000;
  actx        = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: rawPcmSr });
  pcmQueue    = [];
  sprocActive = false;
  rawPcmParts = [];
  chunkQ      = Promise.resolve();
  dlBlob      = null;
  if (!clientT0) clientT0 = performance.now();
  firstChunkAt = null;
  firstAudioAt = null;
  lastBufS     = 0;
  pendingChunks = [];

  if (!(actx.audioWorklet && typeof AudioWorkletNode !== 'undefined')) {
    // Fallback: ScriptProcessor (higher latency)
    document.getElementById('mAudioPath').innerHTML = 'ScriptProcessor';
    sproc = actx.createScriptProcessor(256, 0, 1);
    sproc.onaudioprocess = e => {
      const out = e.outputBuffer.getChannelData(0);
      let i = 0;
      let wrote = false;
      while (i < out.length) {
        if (!pcmQueue.length) { out.fill(0, i); break; }
        const seg  = pcmQueue[0];
        const take = Math.min(out.length - i, seg.data.length - seg.pos);
        out.set(seg.data.subarray(seg.pos, seg.pos + take), i);
        seg.pos += take;
        i       += take;
        wrote = true;
        if (seg.pos >= seg.data.length) pcmQueue.shift();
      }
      if (wrote && firstAudioAt == null) {
        firstAudioAt = performance.now();
        pushClientMetrics();
      }
    };
    if (actx.state === 'suspended') await actx.resume();
    sproc.connect(actx.destination);
    sprocActive = true;
    workletReady = false;
    return;
  }

  document.getElementById('mAudioPath').innerHTML = 'AudioWorklet';
  const processorSrc = `
    class PcmPlayer extends AudioWorkletProcessor {
      constructor() {
        super();
        this.queue = [];
        this.started = false;
        this.port.onmessage = (e) => {
          const d = e.data;
          if (d.type === 'chunk') {
            this.queue.push(new Float32Array(d.data));
          }
        };
      }
      process(inputs, outputs) {
        const out = outputs[0][0];
        let i = 0;
        let wrote = false;
        while (i < out.length) {
          if (!this.queue.length) { out.fill(0, i); break; }
          const seg = this.queue[0];
          const take = Math.min(out.length - i, seg.length);
          out.set(seg.subarray(0, take), i);
          i += take;
          wrote = true;
          if (take < seg.length) {
            this.queue[0] = seg.subarray(take);
          } else {
            this.queue.shift();
          }
        }
        if (wrote && !this.started) {
          this.started = true;
          this.port.postMessage({ type: 'first_audio' });
        }
        return true;
      }
    }
    registerProcessor('pcm-player', PcmPlayer);
  `;

  const blob = new Blob([processorSrc], { type: 'application/javascript' });
  const url = URL.createObjectURL(blob);
  await actx.audioWorklet.addModule(url);
  workletLoadedAt = performance.now();
  URL.revokeObjectURL(url);

  workletNode = new AudioWorkletNode(actx, 'pcm-player');
  workletNode.connect(actx.destination);
  workletNode.port.onmessage = (e) => {
    if (e.data && e.data.type === 'first_audio' && firstAudioAt == null) {
      firstAudioAt = performance.now();
      pushClientMetrics();
    }
  };

  if (actx.state === 'suspended') await actx.resume();
  workletReady = true;
  document.getElementById('mAudioPath').innerHTML = 'AudioWorklet';
  if (!keepAlive) {
    const gain = actx.createGain();
    gain.gain.value = 0;
    const osc = actx.createOscillator();
    osc.connect(gain).connect(actx.destination);
    osc.start();
    keepAlive = { osc, gain };
  }
  pushClientMetrics();

  if (pendingChunks.length) {
    for (const ch of pendingChunks) {
      workletNode.port.postMessage({ type: 'chunk', data: ch });
    }
    pendingChunks = [];
  }
}

// Parse a WAV Uint8Array â†’ {pcm: Float32Array, rawPcm: Uint8Array, sr: number}
function parseWav(bytes) {
  const v  = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);
  const sr = v.getUint32(24, true);
  let off  = 12;
  while (off + 8 <= bytes.length) {
    const id   = String.fromCharCode(bytes[off], bytes[off+1], bytes[off+2], bytes[off+3]);
    const size = v.getUint32(off + 4, true);
    if (id === 'data') {
      const rawPcm = bytes.slice(off + 8, off + 8 + size);
      const i16    = new Int16Array(rawPcm.buffer, rawPcm.byteOffset, rawPcm.byteLength / 2);
      const f32    = new Float32Array(i16.length);
      for (let i = 0; i < i16.length; i++) f32[i] = i16[i] / 32768.0;
      return { pcm: f32, rawPcm, sr };
    }
    off += 8 + size;
  }
  return null;
}

function enqueueChunk(b64wav) {
  chunkQ = chunkQ.then(() => _processChunk(b64wav));
}

function _processChunk(b64wav) {
  if (!actx) return;
  const bytes  = Uint8Array.from(atob(b64wav), c => c.charCodeAt(0));
  const parsed = parseWav(bytes);
  if (!parsed) return;

  if (parsed.sr && parsed.sr !== rawPcmSr) {
    // Re-init audio graph with correct sample rate to avoid pitch issues.
    rawPcmSr = parsed.sr;
    if (actx) { try { actx.close(); } catch {} }
    actx = null;
    workletNode = null;
    workletReady = false;
    pendingChunks = [parsed.pcm];
    initAudio(rawPcmSr);
    return;
  }

  rawPcmParts.push(parsed.rawPcm);
  if (workletReady && workletNode) {
    workletNode.port.postMessage({ type: 'chunk', data: parsed.pcm });
    if (firstWorkletMsgAt == null) {
      firstWorkletMsgAt = performance.now();
      pushClientMetrics();
    }
  } else if (workletNode) {
    pendingChunks.push(parsed.pcm);
  } else {
    pcmQueue.push({ data: parsed.pcm, pos: 0 });
  }
  if (firstChunkAt == null) {
    firstChunkAt = performance.now();
    pushClientMetrics();
  }
  if (workletReady) {
    lastBufS = 0;
  } else {
    lastBufS = pcmQueue.reduce((s, seg) => s + (seg.data.length - seg.pos), 0) / rawPcmSr;
  }
  pushClientMetrics();

  // worklet pulls from its internal queue.
}

// Build download WAV from raw server bytes â€” exact 12 kHz model output, no resampling
function buildWav() {
  if (!rawPcmParts.length) return null;
  const totalPcm = rawPcmParts.reduce((s, p) => s + p.length, 0);
  const ab  = new ArrayBuffer(44 + totalPcm);
  const v   = new DataView(ab);
  const ws  = (o, s) => [...s].forEach((c, i) => v.setUint8(o + i, c.charCodeAt(0)));

  ws(0,  'RIFF'); v.setUint32(4,  36 + totalPcm, true);
  ws(8,  'WAVE'); ws(12, 'fmt ');
  v.setUint32(16, 16, true);
  v.setUint16(20,  1, true);           // PCM
  v.setUint16(22,  1, true);           // mono
  v.setUint32(24, rawPcmSr, true);
  v.setUint32(28, rawPcmSr * 2, true);
  v.setUint16(32,  2, true);
  v.setUint16(34, 16, true);
  ws(36, 'data'); v.setUint32(40, totalPcm, true);

  const out = new Uint8Array(ab, 44);
  let offset = 0;
  for (const part of rawPcmParts) { out.set(part, offset); offset += part.length; }

  return new Blob([ab], { type: 'audio/wav' });
}

// â”€â”€â”€ Metrics helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function resetMetrics() {
  document.getElementById('mAudioPath').innerHTML = 'â€”';
  document.getElementById('mTTFA').innerHTML = 'â€”';
  document.getElementById('mTTFAClient').innerHTML = 'â€”';
  document.getElementById('mVC').innerHTML = 'â€”';
  document.getElementById('mServerWall').innerHTML = 'â€”';
  document.getElementById('mWavMs').innerHTML = 'â€”';
  document.getElementById('mB64Ms').innerHTML = 'â€”';
  document.getElementById('mRTF').innerHTML  = 'â€”';
  document.getElementById('mDur').innerHTML  = 'â€”';
  document.getElementById('mBuf').innerHTML  = 'â€”';
  document.getElementById('mNetClient').innerHTML = 'â€”';
  document.getElementById('mInit').innerHTML = 'â€”';
  document.getElementById('mWorklet').innerHTML = 'â€”';
  document.getElementById('mFirstMsg').innerHTML = 'â€”';
  const pb = document.getElementById('pbar');
  pb.style.width = ''; pb.classList.add('spin');
  document.getElementById('sdot').className  = 'sdot active';
  document.getElementById('stext').textContent = 'Generatingâ€¦';
}

function pushMetrics(ttfa_ms, rtf, audio_s, vc_ms, wav_ms, b64_ms) {
  if (ttfa_ms != null)
    document.getElementById('mTTFA').innerHTML =
      Math.round(ttfa_ms) + '<span class="munit">ms</span>';
  if (vc_ms != null)
    document.getElementById('mVC').innerHTML =
      Math.round(vc_ms) + '<span class="munit">ms</span>';
  if (wav_ms != null)
    document.getElementById('mWavMs').innerHTML =
      Math.round(wav_ms) + '<span class="munit">ms</span>';
  if (b64_ms != null)
    document.getElementById('mB64Ms').innerHTML =
      Math.round(b64_ms) + '<span class="munit">ms</span>';
  if (rtf != null)
    document.getElementById('mRTF').innerHTML =
      rtf.toFixed(2) + '<span class="munit">Ã—</span>';
  if (audio_s != null)
    document.getElementById('mDur').innerHTML =
      audio_s.toFixed(1) + '<span class="munit">s</span>';
}

function pushClientMetrics() {
  if (clientT0) {
    if (firstServerWall != null) {
      document.getElementById('mServerWall').innerHTML =
        Math.round(firstServerWall) + '<span class="munit">ms</span>';
    }
    if (firstAudioAt != null) {
      const ms = firstAudioAt - clientT0;
      document.getElementById('mTTFAClient').innerHTML =
        Math.round(ms) + '<span class="munit">ms</span>';
    } else if (firstChunkAt != null) {
      const ms = firstChunkAt - clientT0;
      document.getElementById('mTTFAClient').innerHTML =
        Math.round(ms) + '<span class="munit">ms</span>';
    }
    if (firstChunkAt != null && firstServerWall != null) {
      const ms = (firstChunkAt - clientT0) - firstServerWall;
      document.getElementById('mNetClient').innerHTML =
        Math.round(ms) + '<span class="munit">ms</span>';
    }
  }
  if (lastBufS != null) {
    document.getElementById('mBuf').innerHTML =
      lastBufS.toFixed(2) + '<span class="munit">s</span>';
  }
  if (initAudioAt != null) {
    document.getElementById('mInit').innerHTML =
      Math.round(initAudioAt - clientT0) + '<span class="munit">ms</span>';
  }
  if (workletLoadedAt != null) {
    document.getElementById('mWorklet').innerHTML =
      Math.round(workletLoadedAt - clientT0) + '<span class="munit">ms</span>';
  }
  if (firstWorkletMsgAt != null) {
    document.getElementById('mFirstMsg').innerHTML =
      Math.round(firstWorkletMsgAt - clientT0) + '<span class="munit">ms</span>';
  }
}

function setDone() {
  document.getElementById('sdot').className = 'sdot done';
  document.getElementById('stext').textContent = 'Done';
  const pb = document.getElementById('pbar');
  pb.classList.remove('spin'); pb.style.width = '100%';
}

function setErr() {
  document.getElementById('sdot').className = 'sdot error';
  document.getElementById('stext').textContent = 'Error';
  const pb = document.getElementById('pbar');
  pb.classList.remove('spin'); pb.style.width = '0%';
}

function setPlayer(blob) {
  dlBlob = blob;
  const url = URL.createObjectURL(blob);
  const player = document.getElementById('player');
  player.src = url;
  document.getElementById('audioWrap').classList.add('show');
}

// â”€â”€â”€ Switch-model prompt â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function showSwitchPrompt(html, targetModel) {
  document.getElementById('switchMsg').innerHTML = html;
  document.getElementById('switchBtn').onclick = () => switchAndGenerate(targetModel);
  document.getElementById('switchPrompt').classList.add('show');
}

async function switchAndGenerate(targetModel) {
  if (busy) return;
  busy = true;
  const btn = document.getElementById('genBtn');
  btn.disabled = true;
  btn.textContent = 'Loading modelâ€¦';
  document.getElementById('modelSelect').value = targetModel;
  dismissSwitch();
  try {
    await loadModel();
  } finally {
    busy = false;
  }
  await generate();
}

function dismissSwitch() {
  document.getElementById('switchPrompt').classList.remove('show');
}

// â”€â”€â”€ Generate â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async function generate() {
  if (busy) return;

  if (activeTab === 'design' && loadedModelName && !loadedModelName.includes('VoiceDesign')) {
    showSwitchPrompt(
      'Voice Design requires the <code>1.7B-VoiceDesign</code> model.',
      'Qwen/Qwen3-TTS-12Hz-1.7B-VoiceDesign',
    );
    return;
  }
  if (activeTab === 'clone' && loadedModelName && loadedModelName.includes('VoiceDesign')) {
    showSwitchPrompt(
      'Voice Clone is not supported by the VoiceDesign model. Switch to a Base model?',
      'Qwen/Qwen3-TTS-12Hz-0.6B-Base',
    );
    return;
  }
  dismissSwitch();

  if (activeTab === 'clone' && !refFile) {
    showErr('Please upload a reference audio file first.'); return;
  }
  hideErr();
  busy = true;

  const btn = document.getElementById('genBtn');
  btn.disabled = true; btn.textContent = 'Generatingâ€¦';

  document.getElementById('mCard').classList.add('show');
  document.getElementById('audioWrap').classList.remove('show');
  document.getElementById('waveRow').classList.remove('hidden');
  resetMetrics();

  const fd = new FormData();
  fd.append('language', document.getElementById('language').value);
  fd.append('temperature', document.getElementById('temperature').value);
  fd.append('top_k', document.getElementById('topK').value);
  fd.append('repetition_penalty', document.getElementById('repPenalty').value);

  if (activeTab === 'clone') {
    fd.append('text', document.getElementById('cloneText').value);
    fd.append('mode', 'voice_clone');
    fd.append('ref_text', document.getElementById('refText').value);
    if (refFile) fd.append('ref_audio', refFile);
  } else {
    fd.append('text', document.getElementById('designText').value);
    fd.append('mode', 'voice_design');
    fd.append('instruct', document.getElementById('instruct').value);
  }

  try {
    if (genMode === 'stream') {
      fd.append('chunk_size', document.getElementById('chunkSize').value);
      await runStreaming(fd);
    } else {
      await runNonStreaming(fd);
    }
  } catch (e) {
    showErr('Generation failed: ' + e.message);
    setErr();
  }

  busy = false;
  btn.disabled = false; btn.textContent = 'Generate';
}

async function runStreaming(fd) {
  document.getElementById('waveRow').classList.remove('hidden');
  clientT0 = performance.now();
  firstChunkAt = null;
  firstAudioAt = null;
  lastBufS = 0;
  firstServerWall = null;
  initAudioAt = null;
  workletLoadedAt = null;
  firstWorkletMsgAt = null;

  if (useWebSocket) {
    await initAudio(24000);
    const ws = new WebSocket(`ws://${location.host}/ws/stream`);
    let audioInited = false;
    ws.onopen = () => {
      const payload = {
        text: fd.get('text'),
        language: fd.get('language'),
        mode: fd.get('mode'),
        ref_text: fd.get('ref_text'),
        instruct: fd.get('instruct'),
        chunk_size: fd.get('chunk_size'),
        temperature: fd.get('temperature'),
        top_k: fd.get('top_k'),
        repetition_penalty: fd.get('repetition_penalty'),
        ref_audio_b64: null,
        ref_id: refId,
      };
      if (refB64) {
        payload.ref_audio_b64 = refB64;
      }
      ws.send(JSON.stringify(payload));
    };

    ws.onmessage = async (ev) => {
      const d = JSON.parse(ev.data);
      if (d.type === 'chunk') {
        if (!audioInited) { await initAudio(d.sample_rate); audioInited = true; }
        if (firstChunkAt == null) {
          firstChunkAt = performance.now();
          if (d.elapsed_ms != null) firstServerWall = d.elapsed_ms;
          pushClientMetrics();
        }
        pushMetrics(d.ttfa_ms, d.rtf, d.total_audio_s, d.voice_clone_ms, d.wav_ms, d.b64_ms);
        enqueueChunk(d.audio_b64);
      } else if (d.type === 'done') {
        pushMetrics(d.ttfa_ms, d.rtf, d.total_audio_s, d.voice_clone_ms, d.wav_ms, d.b64_ms);
        await chunkQ;
        setDone();
        document.getElementById('waveRow').classList.add('hidden');
        const blob = buildWav();
        if (blob) setPlayer(blob);
        ws.close();
      } else if (d.type === 'error') {
        ws.close();
        throw new Error(d.message);
      }
    };
    return;
  }

  const res = await fetch('/generate/stream', { method: 'POST', body: fd });
  if (!res.ok) {
    const e = await res.json();
    throw new Error(e.detail || 'Request failed');
  }

  const reader  = res.body.getReader();
  const decoder = new TextDecoder();
  let buf = '';
  let audioInited = false;

  while (true) {
    const { done, value } = await reader.read();
    if (done) break;
    buf += decoder.decode(value, { stream: true });
    const lines = buf.split('\n');
    buf = lines.pop();

    for (const line of lines) {
      if (!line.startsWith('data: ')) continue;
      const d = JSON.parse(line.slice(6));

      if (d.type === 'chunk') {
        if (!audioInited) { await initAudio(d.sample_rate); audioInited = true; }
        if (firstChunkAt == null) {
          firstChunkAt = performance.now();
          if (d.elapsed_ms != null) firstServerWall = d.elapsed_ms;
          pushClientMetrics();
        }
        pushMetrics(d.ttfa_ms, d.rtf, d.total_audio_s, d.voice_clone_ms, d.wav_ms, d.b64_ms);
        enqueueChunk(d.audio_b64);

      } else if (d.type === 'done') {
        pushMetrics(d.ttfa_ms, d.rtf, d.total_audio_s, d.voice_clone_ms, d.wav_ms, d.b64_ms);
        // Wait for all chunks to be scheduled before marking done
        await chunkQ;
        setDone();
        document.getElementById('waveRow').classList.add('hidden');
        // Build full WAV for replay/download
        const blob = buildWav();
        if (blob) setPlayer(blob);

      } else if (d.type === 'error') {
        throw new Error(d.message);
      }
    }
  }
}

async function runNonStreaming(fd) {
  document.getElementById('waveRow').classList.add('hidden');

  const res = await fetch('/generate', { method: 'POST', body: fd });
  if (!res.ok) {
    const e = await res.json();
    throw new Error(e.detail || 'Request failed');
  }
  const d = await res.json();
  const m = d.metrics;

  // For non-streaming, TTFA == total time (no chunks)
  pushMetrics(m.total_ms, m.rtf, m.audio_duration_s);
  setDone();

  const bytes = Uint8Array.from(atob(d.audio_b64), c => c.charCodeAt(0));
  const blob  = new Blob([bytes], { type: 'audio/wav' });
  setPlayer(blob);
  document.getElementById('player').play();
}

// â”€â”€â”€ Download â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function dlAudio() {
  if (!dlBlob) return;
  const a = Object.assign(document.createElement('a'), {
    href: URL.createObjectURL(dlBlob),
    download: 'generated_speech.wav',
  });
  a.click();
  URL.revokeObjectURL(a.href);
}

// â”€â”€â”€ Error display â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function showErr(msg) {
  const el = document.getElementById('errMsg');
  el.textContent = msg; el.classList.add('show');
}
function hideErr() { document.getElementById('errMsg').classList.remove('show'); }
</script>
</body>
</html>
